/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>

  F* version: <unknown>

 */

#include "where_clauses_simple.h"

/**
This function found in impl {(where_clauses_simple::Ops<K> for usize)#1}
*/
/**
A monomorphic instance of where_clauses_simple.of_u16_56
with const generics
- K= 3
*/
size_t where_clauses_simple_of_u16_56_e0(uint16_t x)
{
  return (size_t)x;
}

/**
This function found in impl {(where_clauses_simple::Ops<K> for usize)#1}
*/
/**
A monomorphic instance of where_clauses_simple.add_56
with const generics
- K= 3
*/
size_t where_clauses_simple_add_56_e0(uint16_t x[3U], size_t y)
{
  return (size_t)x[0U] + y + (size_t)3U;
}

/**
A monomorphic instance of where_clauses_simple.fn_k
with types size_t
with const generics
- K= 3
*/
size_t where_clauses_simple_fn_k_71(void)
{
  size_t x = where_clauses_simple_of_u16_56_e0(0U);
  uint16_t repeat_expression[3U] = { 0U };
  return where_clauses_simple_add_56_e0(repeat_expression, x);
}

typedef struct const_size_t__x2_s
{
  const size_t *fst;
  const size_t *snd;
}
const_size_t__x2;

void where_clauses_simple_k_calls_k(void)
{
  size_t r = where_clauses_simple_fn_k_71();
  size_t r_expected = (size_t)3U;
  const_size_t__x2 uu____0 = { CFIELD(.fst, &r), CFIELD(.snd, &r_expected) };
  const size_t *left_val = uu____0.fst;
  const size_t *right_val = uu____0.snd;
  EURYDICE_ASSERT(left_val[0U] == right_val[0U], "panic!");
}

/**
This function found in impl {(where_clauses_simple::Ops<1: usize> for u64)}
*/
uint64_t where_clauses_simple_add_d9(uint16_t x[1U], uint64_t y)
{
  return (uint64_t)x[0U] + y;
}

/**
This function found in impl {(where_clauses_simple::Ops<1: usize> for u64)}
*/
uint64_t where_clauses_simple_of_u16_d9(uint16_t x)
{
  return (uint64_t)x;
}

/**
A monomorphic instance of where_clauses_simple.fn_k
with types uint64_t
with const generics
- K= 1
*/
uint64_t where_clauses_simple_fn_k_3a(void)
{
  uint64_t x = where_clauses_simple_of_u16_d9(0U);
  uint16_t repeat_expression[1U] = { 0U };
  return where_clauses_simple_add_d9(repeat_expression, x);
}

typedef struct const_uint64_t__x2_s
{
  const uint64_t *fst;
  const uint64_t *snd;
}
const_uint64_t__x2;

void where_clauses_simple_k_calls_one(void)
{
  uint64_t r = where_clauses_simple_fn_k_3a();
  uint64_t r_expected = 0ULL;
  const_uint64_t__x2 uu____0 = { CFIELD(.fst, &r), CFIELD(.snd, &r_expected) };
  const uint64_t *left_val = uu____0.fst;
  const uint64_t *right_val = uu____0.snd;
  EURYDICE_ASSERT(left_val[0U] == right_val[0U], "panic!");
}

/**
This function found in impl {(where_clauses_simple::Ops<K> for usize)#1}
*/
/**
A monomorphic instance of where_clauses_simple.of_u16_56
with const generics
- K= 1
*/
size_t where_clauses_simple_of_u16_56_74(uint16_t x)
{
  return (size_t)x;
}

/**
This function found in impl {(where_clauses_simple::Ops<K> for usize)#1}
*/
/**
A monomorphic instance of where_clauses_simple.add_56
with const generics
- K= 1
*/
size_t where_clauses_simple_add_56_74(uint16_t x[1U], size_t y)
{
  return (size_t)x[0U] + y + (size_t)1U;
}

/**
A monomorphic instance of where_clauses_simple.fn_1
with types size_t
with const generics

*/
size_t where_clauses_simple_fn_1_e6(void)
{
  size_t x = where_clauses_simple_of_u16_56_74(0U);
  uint16_t repeat_expression[1U] = { 0U };
  return where_clauses_simple_add_56_74(repeat_expression, x);
}

void where_clauses_simple_one_calls_k(void)
{
  size_t r = where_clauses_simple_fn_1_e6();
  size_t r_expected = (size_t)1U;
  const_size_t__x2 uu____0 = { CFIELD(.fst, &r), CFIELD(.snd, &r_expected) };
  const size_t *left_val = uu____0.fst;
  const size_t *right_val = uu____0.snd;
  EURYDICE_ASSERT(left_val[0U] == right_val[0U], "panic!");
}

/**
A monomorphic instance of where_clauses_simple.fn_1
with types uint64_t
with const generics

*/
uint64_t where_clauses_simple_fn_1_6f(void)
{
  uint64_t x = where_clauses_simple_of_u16_d9(0U);
  uint16_t repeat_expression[1U] = { 0U };
  return where_clauses_simple_add_d9(repeat_expression, x);
}

void where_clauses_simple_one_calls_one(void)
{
  uint64_t r = where_clauses_simple_fn_1_6f();
  uint64_t r_expected = 0ULL;
  const_uint64_t__x2 uu____0 = { CFIELD(.fst, &r), CFIELD(.snd, &r_expected) };
  const uint64_t *left_val = uu____0.fst;
  const uint64_t *right_val = uu____0.snd;
  EURYDICE_ASSERT(left_val[0U] == right_val[0U], "panic!");
}

/**
A monomorphic instance of where_clauses_simple.double
with types uint64_t, size_t
with const generics

*/
tuple_65 where_clauses_simple_double_47(uint64_t x, size_t y)
{
  tuple_65 lit;
  uint16_t repeat_expression[1U] = { 0U };
  lit.fst = where_clauses_simple_add_d9(repeat_expression, x);
  uint16_t repeat_expression0[1U] = { 0U };
  lit.snd = where_clauses_simple_add_56_74(repeat_expression0, y);
  return lit;
}

/**
A monomorphic instance of where_clauses_simple.double_k
with types size_t, uint64_t
with const generics
- K= 3
*/
tuple_b6 where_clauses_simple_double_k_7b(size_t x, uint64_t y)
{
  tuple_b6 lit;
  uint16_t repeat_expression[3U] = { 0U };
  lit.fst = where_clauses_simple_add_56_e0(repeat_expression, x);
  uint16_t repeat_expression0[1U] = { 0U };
  lit.snd = where_clauses_simple_add_d9(repeat_expression0, y);
  return lit;
}

void where_clauses_simple_main(void)
{
  where_clauses_simple_k_calls_k();
  where_clauses_simple_k_calls_one();
  where_clauses_simple_one_calls_k();
  where_clauses_simple_one_calls_one();
  tuple_65 x = where_clauses_simple_double_47(1ULL, (size_t)1U);
  tuple_b6 y = where_clauses_simple_double_k_7b((size_t)1U, 1ULL);
  uint64_t x_0 = 1ULL;
  size_t x_1 = (size_t)2U;
  const_uint64_t__x2 uu____0 = { CFIELD(.fst, &x.fst), CFIELD(.snd, &x_0) };
  const uint64_t *left_val0 = uu____0.fst;
  const uint64_t *right_val0 = uu____0.snd;
  EURYDICE_ASSERT(left_val0[0U] == right_val0[0U], "panic!");
  const_size_t__x2 uu____1 = { CFIELD(.fst, &x.snd), CFIELD(.snd, &x_1) };
  const size_t *left_val1 = uu____1.fst;
  const size_t *right_val1 = uu____1.snd;
  EURYDICE_ASSERT(left_val1[0U] == right_val1[0U], "panic!");
  size_t y_0 = (size_t)4U;
  uint64_t y_1 = 1ULL;
  const_size_t__x2 uu____2 = { CFIELD(.fst, &y.fst), CFIELD(.snd, &y_0) };
  const size_t *left_val2 = uu____2.fst;
  const size_t *right_val2 = uu____2.snd;
  EURYDICE_ASSERT(left_val2[0U] == right_val2[0U], "panic!");
  const_uint64_t__x2 uu____3 = { CFIELD(.fst, &y.snd), CFIELD(.snd, &y_1) };
  const uint64_t *left_val = uu____3.fst;
  const uint64_t *right_val = uu____3.snd;
  EURYDICE_ASSERT(left_val[0U] == right_val[0U], "panic!");
}

