/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>

  F* version: <unknown>

 */

#include "array.h"

array_Foo array_mk_foo(void)
{
  uint32_t x[2U] = { 0U };
  uint32_t y[2U];
  for (uint32_t _i = 0U; _i < (size_t)2U; ++_i)
    y[_i] = 1U;
  /* Passing arrays by value in Rust generates a copy in C */
  uint32_t copy_of_x[2U];
  memcpy(copy_of_x, x, (size_t)2U * sizeof (uint32_t));
  /* Passing arrays by value in Rust generates a copy in C */
  uint32_t copy_of_y[2U];
  memcpy(copy_of_y, y, (size_t)2U * sizeof (uint32_t));
  array_Foo lit;
  memcpy(lit.x, copy_of_x, (size_t)2U * sizeof (uint32_t));
  memcpy(lit.y, copy_of_y, (size_t)2U * sizeof (uint32_t));
  return lit;
}

array_Foo array_mk_foo2(void)
{
  return array_mk_foo();
}

void array_mut_array(uint32_t x[2U])
{
  x[0U] = 1U;
}

void array_mut_foo(array_Foo f)
{
  f.x[0U] = 1U;
  uint32_t copy[2U];
  memcpy(copy, f.y, (size_t)2U * sizeof (uint32_t));
  copy[0U] = 0U;
}

/**
A monomorphic instance of array.mk_incr
with const generics
- K= 10
*/
void array_mk_incr_95(uint32_t ret[10U])
{
  KRML_MAYBE_FOR10(i0,
    (size_t)0U,
    (size_t)10U,
    (size_t)1U,
    size_t i = i0;
    ret[i0] = (uint32_t)i;);
}

/**
A monomorphic instance of array.mk_incr2
with const generics
- K= 10
*/
void array_mk_incr2_95(uint32_t ret[10U])
{
  uint32_t j = 1U;
  uint32_t ret0[10U];
  KRML_MAYBE_FOR10(i0,
    (size_t)0U,
    (size_t)10U,
    (size_t)1U,
    size_t i = i0;
    /* original Rust expression is not an lvalue in C */
    uint32_t *lvalue = &j;
    ret0[i0] = (uint32_t)i + lvalue[0U];);
  memcpy(ret, ret0, (size_t)10U * sizeof (uint32_t));
}

/**
A monomorphic instance of array.plus_one
with const generics
- K= 1
*/
void array_plus_one_74(uint32_t x[1U], uint16_t ret[1U])
{
  /* Passing arrays by value in Rust generates a copy in C */
  uint32_t copy_of_x[1U];
  memcpy(copy_of_x, x, (size_t)1U * sizeof (uint32_t));
  uint16_t ret0[1U];
  {
    uint32_t x1 = copy_of_x[0U];
    uint32_t x0 = x1;
    ret0[0U] = (uint16_t)(x0 + 1U);
  }
  memcpy(ret, ret0, (size_t)1U * sizeof (uint16_t));
}

/**
A monomorphic instance of array.nested_from_fn
with const generics
- K= 4
*/
void array_nested_from_fn_ac(size_t ret[4U][4U])
{
  KRML_MAYBE_FOR4(i0,
    (size_t)0U,
    (size_t)4U,
    (size_t)1U,
    size_t *x2 = ret[i0];
    size_t j = i0;
    size_t ret0[4U];
    KRML_MAYBE_FOR4(i1,
      (size_t)0U,
      (size_t)4U,
      (size_t)1U,
      size_t i = i1;
      /* original Rust expression is not an lvalue in C */
      size_t *lvalue = &j;
      ret0[i1] = i + lvalue[0U];);
    memcpy(x2, ret0, (size_t)4U * sizeof (size_t)););
}

typedef struct _uint32_t__x2_s
{
  uint32_t *fst;
  uint32_t *snd;
}
_uint32_t__x2;

typedef struct _uint16_t__x2_s
{
  uint16_t *fst;
  uint16_t *snd;
}
_uint16_t__x2;

typedef struct _size_t__x2_s
{
  size_t *fst;
  size_t *snd;
}
_size_t__x2;

void array_main(void)
{
  /* XXX1 */
  array_Foo uu____0 = array_mk_foo2();
  uint32_t x[2U];
  memcpy(x, uu____0.x, (size_t)2U * sizeof (uint32_t));
  uint32_t y[2U];
  memcpy(y, uu____0.y, (size_t)2U * sizeof (uint32_t));
  uint32_t unsigned0 = 0U;
  uint32_t uu____1[2U];
  memcpy(uu____1, x, (size_t)2U * sizeof (uint32_t));
  array_mut_array(uu____1);
  /* Passing arrays by value in Rust generates a copy in C */
  uint32_t copy_of_x[2U];
  /* XXX2 */
  memcpy(copy_of_x, x, (size_t)2U * sizeof (uint32_t));
  /* Passing arrays by value in Rust generates a copy in C */
  uint32_t copy_of_y[2U];
  memcpy(copy_of_y, y, (size_t)2U * sizeof (uint32_t));
  array_Foo lit;
  memcpy(lit.x, copy_of_x, (size_t)2U * sizeof (uint32_t));
  memcpy(lit.y, copy_of_y, (size_t)2U * sizeof (uint32_t));
  array_mut_foo(lit);
  _uint32_t__x2 uu____4;
  uu____4.fst = x;
  uu____4.snd = &unsigned0;
  uint32_t *left_val0 = uu____4.fst;
  uint32_t *right_val0 = uu____4.snd;
  EURYDICE_ASSERT(left_val0[0U] == right_val0[0U], "panic!");
  uint32_t a[10U];
  array_mk_incr_95(a);
  _uint32_t__x2 uu____5;
  uu____5.fst = &a[9U];
  /* original Rust expression is not an lvalue in C */
  uint32_t lvalue0 = 9U;
  uu____5.snd = &lvalue0;
  uint32_t *left_val1 = uu____5.fst;
  uint32_t *right_val1 = uu____5.snd;
  EURYDICE_ASSERT(left_val1[0U] == right_val1[0U], "panic!");
  uint32_t a0[10U];
  array_mk_incr2_95(a0);
  uint32_t expected = 10U;
  _uint32_t__x2 uu____6;
  uu____6.fst = &a0[9U];
  uu____6.snd = &expected;
  uint32_t *left_val = uu____6.fst;
  uint32_t *right_val2 = uu____6.snd;
  EURYDICE_ASSERT(left_val[0U] == right_val2[0U], "panic!");
  uint16_t a1[1U];
  uint32_t buf[1U] = { 0U };
  array_plus_one_74(buf, a1);
  _uint16_t__x2 uu____7;
  uu____7.fst = a1;
  /* original Rust expression is not an lvalue in C */
  uint16_t lvalue1 = 1U;
  uu____7.snd = &lvalue1;
  uint16_t *left_val2 = uu____7.fst;
  uint16_t *right_val3 = uu____7.snd;
  EURYDICE_ASSERT(left_val2[0U] == right_val3[0U], "panic!");
  /* XXX5 */
  size_t a2[4U][4U];
  array_nested_from_fn_ac(a2);
  _size_t__x2 uu____8;
  uu____8.fst = &a2[3U][3U];
  /* original Rust expression is not an lvalue in C */
  size_t lvalue = (size_t)6U;
  uu____8.snd = &lvalue;
  size_t *left_val3 = uu____8.fst;
  size_t *right_val = uu____8.snd;
  EURYDICE_ASSERT(left_val3[0U] == right_val[0U], "panic!");
}

