/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>

  F* version: <unknown>

 */

#include "symcrust.h"

#include "internal/Eurydice.h"

/**
A monomorphic instance of Eurydice.slice_subslice_mut
with types uint8_t, core_ops_range_Range size_t, Eurydice_derefed_slice uint8_t

*/
static Eurydice_mut_borrow_slice_u8
slice_subslice_mut_7e(Eurydice_mut_borrow_slice_u8 s, core_ops_range_Range_08 r)
{
  return
    (
      KRML_CLITERAL(Eurydice_mut_borrow_slice_u8){ .ptr = s.ptr + r.start, .meta = r.end - r.start }
    );
}

/**
A monomorphic instance of Eurydice.array_to_slice_shared
with types uint8_t
with const generics
- N= 4
*/
static Eurydice_borrow_slice_u8 array_to_slice_shared_60(const Eurydice_array_u8x4 *a)
{
  Eurydice_borrow_slice_u8 lit;
  lit.ptr = a->data;
  lit.meta = (size_t)4U;
  return lit;
}

void
symcrust_SymCrustMlKemPolyElementCompressAndEncode(
  const Eurydice_arr_bc *coeffs,
  uint32_t nBitsPerCoefficient,
  Eurydice_mut_borrow_slice_u8 dst
)
{
  uint64_t SYMCRYPT_MLKEM_COMPRESS_MULCONSTANT = 10321339ULL;
  uint32_t SYMCRYPT_MLKEM_COMPRESS_SHIFTCONSTANT = 35U;
  size_t cbDstWritten = (size_t)0U;
  uint32_t accumulator = 0U;
  uint32_t nBitsInAccumulator = 0U;
  EURYDICE_ASSERT(nBitsPerCoefficient > 0U, "panic!");
  EURYDICE_ASSERT(nBitsPerCoefficient <= 12U, "panic!");
  EURYDICE_ASSERT((uint64_t)Eurydice_slice_len((
        KRML_CLITERAL(Eurydice_borrow_slice_u8){ .ptr = dst.ptr, .meta = dst.meta }
      ),
      uint8_t)
    == 256ULL * (uint64_t)nBitsPerCoefficient / 8ULL,
    "panic!");
  for (size_t i = (size_t)0U; i < (size_t)256U; i++)
  {
    size_t i0 = i;
    uint32_t nBitsInCoefficient = nBitsPerCoefficient;
    uint32_t coefficient = (uint32_t)coeffs->data[i0];
    if (nBitsPerCoefficient < 12U)
    {
      uint64_t multiplication = (uint64_t)coefficient * SYMCRYPT_MLKEM_COMPRESS_MULCONSTANT;
      coefficient =
        (uint32_t)(multiplication >>
          (uint32_t)(SYMCRYPT_MLKEM_COMPRESS_SHIFTCONSTANT - (nBitsPerCoefficient + 1U)));
      coefficient++;
      coefficient = coefficient >> 1U;
      coefficient = coefficient & ((1U << (uint32_t)nBitsPerCoefficient) - 1U);
    }
    while (nBitsInCoefficient > 0U)
    {
      uint32_t nBitsToEncode = Eurydice_min_u32(nBitsInCoefficient, 32U - nBitsInAccumulator);
      uint32_t bitsToEncode = coefficient & ((1U << (uint32_t)nBitsToEncode) - 1U);
      coefficient = coefficient >> (uint32_t)nBitsToEncode;
      nBitsInCoefficient = nBitsInCoefficient - nBitsToEncode;
      accumulator = accumulator | bitsToEncode << (uint32_t)nBitsInAccumulator;
      nBitsInAccumulator = nBitsInAccumulator + nBitsToEncode;
      if (nBitsInAccumulator == 32U)
      {
        Eurydice_mut_borrow_slice_u8
        uu____0 =
          slice_subslice_mut_7e(dst,
            (
              KRML_CLITERAL(core_ops_range_Range_08){
                .start = cbDstWritten,
                .end = cbDstWritten + (size_t)4U
              }
            ));
        /* original Rust expression is not an lvalue in C */
        Eurydice_array_u8x4 lvalue = core_num__u32__to_le_bytes(accumulator);
        Eurydice_slice_copy(uu____0, array_to_slice_shared_60(&lvalue), uint8_t);
        cbDstWritten = cbDstWritten + (size_t)4U;
        accumulator = 0U;
        nBitsInAccumulator = 0U;
      }
    }
  }
}

void symcrust_main(void)
{

}

