/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>

  F* version: <unknown>

 */

#include "slice_array.h"

/**
A monomorphic instance of Eurydice.array_to_slice_mut
with types Eurydice_arr uint8_t[[$4size_t]]
with const generics
- N= 4
*/
static Eurydice_dst_ref_mut_75 array_to_slice_mut_4f(Eurydice_arr_44 *a)
{
  Eurydice_dst_ref_mut_75 lit;
  lit.ptr = a->data;
  lit.meta = (size_t)4U;
  return lit;
}

typedef struct const_uint8_t__x2_s
{
  const uint8_t *fst;
  const uint8_t *snd;
}
const_uint8_t__x2;

void slice_array_f1(void)
{
  Eurydice_arr_44
  x =
    { .data = { { .data = { 0U } }, { .data = { 0U } }, { .data = { 0U } }, { .data = { 0U } } } };
  Eurydice_dst_ref_mut_75
  y0 =
    Eurydice_slice_split_at_mut(array_to_slice_mut_4f(&x),
      (size_t)2U,
      Eurydice_array_u8x4,
      Eurydice_dst_ref_mut_75_x2).fst;
  y0.ptr->data[0U] = 1U;
  uint8_t actual = x.data->data[0U];
  uint8_t expected = 1U;
  const_uint8_t__x2 uu____0 = { .fst = &actual, .snd = &expected };
  EURYDICE_ASSERT(uu____0.fst[0U] == uu____0.snd[0U], "panic!");
}

void slice_array_f2(void)
{
  Eurydice_arr_44
  x =
    { .data = { { .data = { 0U } }, { .data = { 0U } }, { .data = { 0U } }, { .data = { 0U } } } };
  Eurydice_dst_ref_mut_75
  y0 =
    Eurydice_slice_split_at_mut(array_to_slice_mut_4f(&x),
      (size_t)2U,
      Eurydice_array_u8x4,
      Eurydice_dst_ref_mut_75_x2).fst;
  Eurydice_array_u8x4 z = y0.ptr[0U];
  z.data[0U] = 1U;
  uint8_t actual = x.data->data[0U];
  uint8_t expected = 0U;
  const_uint8_t__x2 uu____0 = { .fst = &actual, .snd = &expected };
  EURYDICE_ASSERT(uu____0.fst[0U] == uu____0.snd[0U], "panic!");
  /* original Rust expression is not an lvalue in C */
  uint8_t lvalue = 1U;
  const_uint8_t__x2 uu____1 = { .fst = z.data, .snd = &lvalue };
  EURYDICE_ASSERT(uu____1.fst[0U] == uu____1.snd[0U], "panic!");
}

/**
A monomorphic instance of Eurydice.array_to_slice_shared
with types uint8_t
with const generics
- N= 4
*/
static Eurydice_borrow_slice_u8 array_to_slice_shared_60(const Eurydice_array_u8x4 *a)
{
  Eurydice_borrow_slice_u8 lit;
  lit.ptr = a->data;
  lit.meta = (size_t)4U;
  return lit;
}

/**
This function found in impl {core::result::Result<T, E>[TraitClause@0, TraitClause@1]}
*/
/**
A monomorphic instance of core.result.unwrap_26
with types Eurydice_arr uint8_t[[$4size_t]], core_array_TryFromSliceError

*/
static Eurydice_array_u8x4 unwrap_26_84(core_result_Result_c7 self)
{
  if (self.tag == core_result_Ok)
  {
    return self.val.case_Ok;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "unwrap not Ok");
    KRML_HOST_EXIT(255U);
  }
}

/**
This function found in impl {core::result::Result<T, E>[TraitClause@0, TraitClause@1]}
*/
/**
A monomorphic instance of core.result.unwrap_26
with types const Eurydice_arr uint8_t[[$4size_t]]*, core_array_TryFromSliceError

*/
static const Eurydice_array_u8x4 *unwrap_26_16(core_result_Result_90 self)
{
  if (self.tag == core_result_Ok)
  {
    return self.val.case_Ok;
  }
  else
  {
    KRML_HOST_EPRINTF("KaRaMeL abort at %s:%d\n%s\n", __FILE__, __LINE__, "unwrap not Ok");
    KRML_HOST_EXIT(255U);
  }
}

/**
A monomorphic instance of Eurydice.array_to_slice_mut
with types uint8_t
with const generics
- N= 4
*/
static Eurydice_mut_borrow_slice_u8 array_to_slice_mut_60(Eurydice_array_u8x4 *a)
{
  Eurydice_mut_borrow_slice_u8 lit;
  lit.ptr = a->data;
  lit.meta = (size_t)4U;
  return lit;
}

void slice_array_f3(void)
{
  /* original Rust expression is not an lvalue in C */
  Eurydice_array_u8x4 lvalue0 = { .data = { 0U } };
  Eurydice_borrow_slice_u8 x1 = array_to_slice_shared_60(&lvalue0);
  Eurydice_array_u8x4 arr0;
  memcpy(arr0.data, x1.ptr, (size_t)4U * sizeof (uint8_t));
  Eurydice_array_u8x4
  y1 =
    unwrap_26_84((
        KRML_CLITERAL(core_result_Result_c7){ .tag = core_result_Ok, .val = { .case_Ok = arr0 } }
      ));
  /* original Rust expression is not an lvalue in C */
  Eurydice_array_u8x4 lvalue1 = { .data = { 0U } };
  Eurydice_borrow_slice_u8 x2 = array_to_slice_shared_60(&lvalue1);
  Eurydice_borrow_slice_u8 uu____0 = x2;
  Eurydice_array_u8x4 arr1;
  memcpy(arr1.data, uu____0.ptr, (size_t)4U * sizeof (uint8_t));
  const
  Eurydice_array_u8x4
  *y2 =
    unwrap_26_16(Eurydice_slice_to_ref_array2((size_t)4U,
        uu____0,
        &arr1,
        Eurydice_borrow_slice_u8,
        const Eurydice_array_u8x4 *,
        core_array_TryFromSliceError,
        core_result_Result_90));
  /* original Rust expression is not an lvalue in C */
  Eurydice_array_u8x4 lvalue = { .data = { 0U } };
  Eurydice_mut_borrow_slice_u8 x3 = array_to_slice_mut_60(&lvalue);
  Eurydice_array_u8x4 arr;
  memcpy(arr.data, x3.ptr, (size_t)4U * sizeof (uint8_t));
  Eurydice_array_u8x4
  y3 =
    unwrap_26_84((
        KRML_CLITERAL(core_result_Result_c7){ .tag = core_result_Ok, .val = { .case_Ok = arr } }
      ));
  const_uint8_t__x2 uu____1 = { .fst = y1.data, .snd = y2->data };
  EURYDICE_ASSERT(uu____1.fst[0U] == uu____1.snd[0U], "panic!");
  const_uint8_t__x2 uu____2 = { .fst = y1.data, .snd = y3.data };
  EURYDICE_ASSERT(uu____2.fst[0U] == uu____2.snd[0U], "panic!");
}

/**
A monomorphic instance of slice_array.f4
with const generics
- K= 4
*/
void slice_array_f4_ac(void)
{
  Eurydice_arr_44
  x =
    { .data = { { .data = { 0U } }, { .data = { 0U } }, { .data = { 0U } }, { .data = { 0U } } } };
  Eurydice_dst_ref_mut_75
  y0 =
    Eurydice_slice_split_at_mut(array_to_slice_mut_4f(&x),
      (size_t)2U,
      Eurydice_array_u8x4,
      Eurydice_dst_ref_mut_75_x2).fst;
  y0.ptr->data[0U] = 1U;
  uint8_t actual = x.data->data[0U];
  uint8_t expected = 1U;
  const_uint8_t__x2 uu____0 = { .fst = &actual, .snd = &expected };
  EURYDICE_ASSERT(uu____0.fst[0U] == uu____0.snd[0U], "panic!");
}

/**
A monomorphic instance of slice_array.f5
with const generics
- K= 4
*/
void slice_array_f5_ac(void)
{
  /* original Rust expression is not an lvalue in C */
  Eurydice_array_u8x4 lvalue0 = { .data = { 0U } };
  Eurydice_borrow_slice_u8 x1 = array_to_slice_shared_60(&lvalue0);
  Eurydice_array_u8x4 arr0;
  memcpy(arr0.data, x1.ptr, (size_t)4U * sizeof (uint8_t));
  Eurydice_array_u8x4
  y1 =
    unwrap_26_84((
        KRML_CLITERAL(core_result_Result_c7){ .tag = core_result_Ok, .val = { .case_Ok = arr0 } }
      ));
  /* original Rust expression is not an lvalue in C */
  Eurydice_array_u8x4 lvalue = { .data = { 0U } };
  Eurydice_borrow_slice_u8
  x2 = core_array___Array_T__N___as_slice((size_t)4U, &lvalue, uint8_t, Eurydice_borrow_slice_u8);
  Eurydice_borrow_slice_u8 uu____0 = x2;
  Eurydice_array_u8x4 arr;
  memcpy(arr.data, uu____0.ptr, (size_t)4U * sizeof (uint8_t));
  const
  Eurydice_array_u8x4
  *y2 =
    unwrap_26_16(Eurydice_slice_to_ref_array2((size_t)4U,
        uu____0,
        &arr,
        Eurydice_borrow_slice_u8,
        const Eurydice_array_u8x4 *,
        core_array_TryFromSliceError,
        core_result_Result_90));
  const_uint8_t__x2 uu____1 = { .fst = y1.data, .snd = y2->data };
  EURYDICE_ASSERT(uu____1.fst[0U] == uu____1.snd[0U], "panic!");
}

void slice_array_main(void)
{
  slice_array_f1();
  slice_array_f2();
  slice_array_f3();
  slice_array_f4_ac();
  slice_array_f5_ac();
}

