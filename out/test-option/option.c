/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>

  F* version: <unknown>

 */

#include "option.h"

void option_main(void)
{

}

/**
 Converts from `&Option<T>` to `Option<&T>`.

 # Examples

 Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>
 without moving the [`String`]. The [`map`] method takes the `self` argument by value,
 consuming the original, so this technique uses `as_ref` to first take an `Option` to a
 reference to the value inside the original.

 [`map`]: Option::map
 [String]: ../../std/string/struct.String.html "String"
 [`String`]: ../../std/string/struct.String.html "String"

 ```
 let text: Option<String> = Some("Hello, world!".to_string());
 // First, cast `Option<String>` to `Option<&String>` with `as_ref`,
 // then consume *that* with `map`, leaving `text` on the stack.
 let text_length: Option<usize> = text.as_ref().map(|s| s.len());
 println!("still can print text: {text:?}");
 ```
*/
/**
This function found in impl {core::option::Option<T>[TraitClause@0]}
*/
/**
A monomorphic instance of core.option.as_ref_cd
with types Eurydice_arr uint8_t[[$16size_t]]

*/
inline core_option_Option_18 core_option_as_ref_cd_ca(core_option_Option_62 *self)
{
  if (!(self->tag == core_option_None))
  {
    Eurydice_arr_88 *x = &self->f0;
    return (KRML_CLITERAL(core_option_Option_18){ .tag = core_option_Some, .f0 = x });
  }
  return (KRML_CLITERAL(core_option_Option_18){ .tag = core_option_None });
}

/**
This function found in impl {option::S}
*/
core_option_Option_18 option_option_ref_b6(core_option_Option_62 *self)
{
  return core_option_as_ref_cd_ca(self);
}

