/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>

  F* version: <unknown>

 */

#include "const_generics.h"

/**
A monomorphic instance of Eurydice.array_to_subslice_to
with types uint8_t, core_ops_range_RangeTo size_t, Eurydice_derefed_slice uint8_t
with const generics
- N= 8
*/
static Eurydice_dst_ref_87 array_to_subslice_to_6e(Eurydice_arr_c4 *a, size_t r)
{
  Eurydice_dst_ref_87 lit;
  lit.ptr = a->data;
  lit.meta = r;
  return lit;
}

/**
A monomorphic instance of Eurydice.array_to_slice
with types uint8_t
with const generics
- N= 4
*/
static Eurydice_dst_ref_87 array_to_slice_60(Eurydice_arr_e9 *a)
{
  Eurydice_dst_ref_87 lit;
  lit.ptr = a->data;
  lit.meta = (size_t)4U;
  return lit;
}

/**
A monomorphic instance of Eurydice.array_to_subslice_from
with types uint8_t, core_ops_range_RangeFrom size_t, Eurydice_derefed_slice uint8_t
with const generics
- N= 8
*/
static Eurydice_dst_ref_87 array_to_subslice_from_8c(Eurydice_arr_c4 *a, size_t r)
{
  return (KRML_CLITERAL(Eurydice_dst_ref_87){ .ptr = a->data + r, .meta = (size_t)8U - r });
}

/**
A monomorphic instance of const_generics.serialize
with const generics
- OUT_LEN= 8
*/
Eurydice_arr_c4 const_generics_serialize_3b(Eurydice_dst_ref_3c re)
{
  Eurydice_arr_c4 out = { .data = { 0U } };
  Eurydice_dst_ref_87 uu____0 = array_to_subslice_to_6e(&out, (size_t)4U);
  /* original Rust expression is not an lvalue in C */
  Eurydice_arr_e9
  lvalue0 =
    core_num__u32__to_be_bytes(Eurydice_slice_index(re, (size_t)0U, uint32_t, uint32_t *));
  Eurydice_slice_copy(uu____0, array_to_slice_60(&lvalue0), uint8_t);
  Eurydice_dst_ref_87 uu____1 = array_to_subslice_from_8c(&out, (size_t)4U);
  /* original Rust expression is not an lvalue in C */
  Eurydice_arr_e9
  lvalue = core_num__u32__to_be_bytes(Eurydice_slice_index(re, (size_t)1U, uint32_t, uint32_t *));
  Eurydice_slice_copy(uu____1, array_to_slice_60(&lvalue), uint8_t);
  return out;
}

/**
A monomorphic instance of Eurydice.array_to_slice
with types uint32_t
with const generics
- N= 2
*/
static Eurydice_dst_ref_3c array_to_slice_a1(Eurydice_arr_b2 *a)
{
  Eurydice_dst_ref_3c lit;
  lit.ptr = a->data;
  lit.meta = (size_t)2U;
  return lit;
}

void const_generics_main(void)
{
  /* original Rust expression is not an lvalue in C */
  Eurydice_arr_b2 lvalue = { .data = { 1U, 2U } };
  Eurydice_arr_c4 s = const_generics_serialize_3b(array_to_slice_a1(&lvalue));
  EURYDICE_ASSERT(s.data[3U] == 1U, "panic!");
  EURYDICE_ASSERT(s.data[7U] == 2U, "panic!");
}

/**
A monomorphic instance of const_generics.mk_pairs
with types uint32_t, uint64_t
with const generics
- N= 2
- M= 4
*/
const_generics_Pair_4e const_generics_mk_pairs_e0(uint32_t x, uint64_t y)
{
  Eurydice_arr_b2 a1;
  uint32_t repeat_expression0[2U];
  KRML_MAYBE_FOR2(i, (size_t)0U, (size_t)2U, (size_t)1U, repeat_expression0[i] = x;);
  memcpy(a1.data, repeat_expression0, (size_t)2U * sizeof (uint32_t));
  Eurydice_arr_61 a2;
  uint64_t repeat_expression[4U];
  KRML_MAYBE_FOR4(i, (size_t)0U, (size_t)4U, (size_t)1U, repeat_expression[i] = y;);
  memcpy(a2.data, repeat_expression, (size_t)4U * sizeof (uint64_t));
  const_generics_Pair_a5 p1 = { .left = a1, .right = a2 };
  const_generics_Pair_87 p2 = { .left = a2, .right = a1 };
  return (KRML_CLITERAL(const_generics_Pair_4e){ .left = p1.left, .right = p2.right });
}

typedef struct _uint32_t__x2_s
{
  uint32_t *fst;
  uint32_t *snd;
}
_uint32_t__x2;

void const_generics_main1(void)
{
  const_generics_Pair_4e uu____0 = const_generics_mk_pairs_e0(0U, 0ULL);
  Eurydice_arr_b2 left = uu____0.left;
  Eurydice_arr_b2 right = uu____0.right;
  uint32_t expected = 0U;
  _uint32_t__x2 uu____1 = { .fst = left.data, .snd = &expected };
  EURYDICE_ASSERT(uu____1.fst[0U] == uu____1.snd[0U], "panic!");
  _uint32_t__x2 uu____2 = { .fst = &left.data[1U], .snd = &expected };
  EURYDICE_ASSERT(uu____2.fst[0U] == uu____2.snd[0U], "panic!");
  _uint32_t__x2 uu____3 = { .fst = right.data, .snd = &expected };
  EURYDICE_ASSERT(uu____3.fst[0U] == uu____3.snd[0U], "panic!");
  _uint32_t__x2 uu____4 = { .fst = &right.data[1U], .snd = &expected };
  EURYDICE_ASSERT(uu____4.fst[0U] == uu____4.snd[0U], "panic!");
}

/**
A monomorphic instance of const_generics.f
with const generics
- FOO= 1
- BAR= 2
*/
bool const_generics_f_e5(uint32_t x, size_t y)
{
  Eurydice_arr_a5 arr1;
  uint32_t repeat_expression0[1U];
  {
    repeat_expression0[0U] = x;
  }
  memcpy(arr1.data, repeat_expression0, (size_t)1U * sizeof (uint32_t));
  Eurydice_arr_e4 arr2;
  size_t repeat_expression[1U];
  {
    repeat_expression[0U] = y;
  }
  memcpy(arr2.data, repeat_expression, (size_t)1U * sizeof (size_t));
  bool uu____0;
  if (arr1.data[0U] == 2U)
  {
    uu____0 = arr2.data[0U] == (size_t)1U;
  }
  else
  {
    uu____0 = false;
  }
  return uu____0;
}

/**
A monomorphic instance of const_generics.f
with const generics
- FOO= 3
- BAR= 4
*/
bool const_generics_f_70(uint32_t x, size_t y)
{
  Eurydice_arr_6f arr1;
  uint32_t repeat_expression0[3U];
  KRML_MAYBE_FOR3(i, (size_t)0U, (size_t)3U, (size_t)1U, repeat_expression0[i] = x;);
  memcpy(arr1.data, repeat_expression0, (size_t)3U * sizeof (uint32_t));
  Eurydice_arr_c8 arr2;
  size_t repeat_expression[3U];
  KRML_MAYBE_FOR3(i, (size_t)0U, (size_t)3U, (size_t)1U, repeat_expression[i] = y;);
  memcpy(arr2.data, repeat_expression, (size_t)3U * sizeof (size_t));
  bool uu____0;
  if (arr1.data[0U] == 4U)
  {
    uu____0 = arr2.data[0U] == (size_t)3U;
  }
  else
  {
    uu____0 = false;
  }
  return uu____0;
}

/**
A monomorphic instance of const_generics.g
with const generics
- BAR= 3
- FOO= 4
*/
bool const_generics_g_70(uint32_t x, size_t y)
{
  bool uu____0;
  if (const_generics_f_70(x, y))
  {
    if (x == 4U)
    {
      uu____0 = y == (size_t)3U;
    }
    else
    {
      uu____0 = false;
    }
  }
  else
  {
    uu____0 = false;
  }
  return uu____0;
}

typedef struct _bool__x2_s
{
  bool *fst;
  bool *snd;
}
_bool__x2;

void const_generics_main3(void)
{
  bool x;
  if (const_generics_f_e5(0U, (size_t)0U))
  {
    x = const_generics_g_70(0U, (size_t)0U);
  }
  else
  {
    x = false;
  }
  bool expected = false;
  _bool__x2 uu____0 = { .fst = &x, .snd = &expected };
  EURYDICE_ASSERT(uu____0.fst[0U] == uu____0.snd[0U], "panic!");
}

