/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>

  F* version: <unknown>

 */

#include "nested_arrays.h"

#include "Eurydice.h"

const uint32_t nested_arrays_ZERO[8U] = { 0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U };

typedef struct _uint32_t__x2_s
{
  uint32_t *fst;
  uint32_t *snd;
}
_uint32_t__x2;

void nested_arrays_main(void)
{
  uint32_t keys[3U][3U][8U];
  for (size_t i0 = (size_t)0U; i0 < (size_t)3U; i0++)
  {
    uint32_t repeat_expression[3U][8U];
    for (size_t i = (size_t)0U; i < (size_t)3U; i++)
    {
      memcpy(repeat_expression[i], nested_arrays_ZERO, (size_t)8U * sizeof (uint32_t));
    }
    memcpy(keys[i0], repeat_expression, (size_t)3U * sizeof (uint32_t [8U]));
  }
  core_ops_range_Range__usize_
  iter0 =
    core_iter_traits_collect__core__iter__traits__collect__IntoIterator___core__ops__range__Range___usize____into_iter__core__ops__range__Range___usize__((
        KRML_CLITERAL(core_ops_range_Range__usize_){ .start = (size_t)0U, .end = (size_t)3U }
      ));
  while (true)
  {
    core_option_Option__usize_
    uu____0 =
      core_iter_range__core__iter__traits__iterator__Iterator___core__ops__range__Range___usize____next__usize_(&iter0);
    if (uu____0.tag == core_option_Option_None)
    {
      break;
    }
    else
    {
      size_t i = uu____0.f0;
      core_ops_range_Range__usize_
      iter1 =
        core_iter_traits_collect__core__iter__traits__collect__IntoIterator___core__ops__range__Range___usize____into_iter__core__ops__range__Range___usize__((
            KRML_CLITERAL(core_ops_range_Range__usize_){ .start = (size_t)0U, .end = (size_t)3U }
          ));
      while (true)
      {
        core_option_Option__usize_
        uu____1 =
          core_iter_range__core__iter__traits__iterator__Iterator___core__ops__range__Range___usize____next__usize_(&iter1);
        if (uu____1.tag == core_option_Option_None)
        {
          break;
        }
        else
        {
          size_t j = uu____1.f0;
          core_ops_range_Range__usize_
          iter =
            core_iter_traits_collect__core__iter__traits__collect__IntoIterator___core__ops__range__Range___usize____into_iter__core__ops__range__Range___usize__((
                KRML_CLITERAL(core_ops_range_Range__usize_){
                  .start = (size_t)0U,
                  .end = (size_t)8U
                }
              ));
          while (true)
          {
            core_option_Option__usize_
            uu____2 =
              core_iter_range__core__iter__traits__iterator__Iterator___core__ops__range__Range___usize____next__usize_(&iter);
            if (uu____2.tag == core_option_Option_None)
            {
              break;
            }
            else
            {
              size_t k = uu____2.f0;
              uint32_t actual = keys[i][j][k];
              uint32_t expected = (uint32_t)k;
              _uint32_t__x2 uu____3 = { .fst = &actual, .snd = &expected };
              EURYDICE_ASSERT(uu____3.fst[0U] == uu____3.snd[0U], "panic!");
            }
          }
        }
      }
    }
  }
}

void nested_arrays_test(uint8_t ret[4U][200U])
{
  uint8_t out0[200U] = { 0U };
  uint8_t out1[200U] = { 0U };
  uint8_t out2[200U] = { 0U };
  uint8_t out3[200U] = { 0U };
  /* Passing arrays by value in Rust generates a copy in C */
  uint8_t copy_of_out0[200U];
  memcpy(copy_of_out0, out0, (size_t)200U * sizeof (uint8_t));
  /* Passing arrays by value in Rust generates a copy in C */
  uint8_t copy_of_out1[200U];
  memcpy(copy_of_out1, out1, (size_t)200U * sizeof (uint8_t));
  /* Passing arrays by value in Rust generates a copy in C */
  uint8_t copy_of_out2[200U];
  memcpy(copy_of_out2, out2, (size_t)200U * sizeof (uint8_t));
  uint8_t uu____3[200U];
  memcpy(uu____3, out3, (size_t)200U * sizeof (uint8_t));
  memcpy(ret[0U], copy_of_out0, (size_t)200U * sizeof (uint8_t));
  memcpy(ret[1U], copy_of_out1, (size_t)200U * sizeof (uint8_t));
  memcpy(ret[2U], copy_of_out2, (size_t)200U * sizeof (uint8_t));
  memcpy(ret[3U], uu____3, (size_t)200U * sizeof (uint8_t));
}

